; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25834.0 

	TITLE	C:\Users\b54275\Desktop\Lab3-Oper\demo25\SysCore\FloppyDisk\flpydsk.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?flpydsk_install@@YAXH@Z			; flpydsk_install
PUBLIC	?flpydsk_set_working_drive@@YAXE@Z		; flpydsk_set_working_drive
PUBLIC	?flpydsk_get_working_drive@@YAEXZ		; flpydsk_get_working_drive
PUBLIC	?flpydsk_read_sector@@YAPAEH@Z			; flpydsk_read_sector
PUBLIC	?flpydsk_lba_to_chs@@YAXHPAH00@Z		; flpydsk_lba_to_chs
PUBLIC	?dma_initialize_floppy@@YA_NPAEI@Z		; dma_initialize_floppy
PUBLIC	?flpydsk_read_status@@YAEXZ			; flpydsk_read_status
PUBLIC	?flpydsk_write_dor@@YAXE@Z			; flpydsk_write_dor
PUBLIC	?flpydsk_send_command@@YAXE@Z			; flpydsk_send_command
PUBLIC	?flpydsk_read_data@@YAEXZ			; flpydsk_read_data
PUBLIC	?flpydsk_write_ccr@@YAXE@Z			; flpydsk_write_ccr
PUBLIC	?i86_flpy_irq@@YAXXZ				; i86_flpy_irq
PUBLIC	?flpydsk_check_int@@YAXPAI0@Z			; flpydsk_check_int
PUBLIC	?flpydsk_control_motor@@YAX_N@Z			; flpydsk_control_motor
PUBLIC	?flpydsk_drive_data@@YAXEEE_N@Z			; flpydsk_drive_data
PUBLIC	?flpydsk_calibrate@@YAHE@Z			; flpydsk_calibrate
PUBLIC	?flpydsk_disable_controller@@YAXXZ		; flpydsk_disable_controller
PUBLIC	?flpydsk_enable_controller@@YAXXZ		; flpydsk_enable_controller
PUBLIC	?flpydsk_reset@@YAXXZ				; flpydsk_reset
PUBLIC	?flpydsk_read_sector_imp@@YAXEEE@Z		; flpydsk_read_sector_imp
PUBLIC	?flpydsk_seek@@YAHEE@Z				; flpydsk_seek
EXTRN	?inportb@@YAEG@Z:PROC				; inportb
EXTRN	?outportb@@YAXGE@Z:PROC				; outportb
EXTRN	?setvect@@YAXHA6AXXZH@Z:PROC			; setvect
EXTRN	?interruptdone@@YAXI@Z:PROC			; interruptdone
EXTRN	?dma_set_read@@YAXE@Z:PROC			; dma_set_read
EXTRN	?dma_set_address@@YAXEEE@Z:PROC			; dma_set_address
EXTRN	?dma_set_count@@YAXEEE@Z:PROC			; dma_set_count
EXTRN	?dma_mask_channel@@YAXE@Z:PROC			; dma_mask_channel
EXTRN	?dma_reset_flipflop@@YAXH@Z:PROC		; dma_reset_flipflop
EXTRN	?dma_reset@@YAXH@Z:PROC				; dma_reset
EXTRN	?dma_unmask_all@@YAXH@Z:PROC			; dma_unmask_all
EXTRN	?sleep@@YAXH@Z:PROC				; sleep
_BSS	SEGMENT
?_CurrentDrive@@3EA DB 01H DUP (?)			; _CurrentDrive
?_FloppyDiskIRQ@@3EC DB 01H DUP (?)			; _FloppyDiskIRQ
_BSS	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_cmd$ = -4						; size = 1
_cyl$ = 8						; size = 1
_head$ = 12						; size = 1
?flpydsk_seek@@YAHEE@Z PROC				; flpydsk_seek

; 475  : int flpydsk_seek ( uint8_t cyl, uint8_t head ) {

	push	ecx

; 476  : 
; 477  : 	uint32_t st0, cyl0;
; 478  : 
; 479  : 	if (_CurrentDrive >= 4)

	cmp	BYTE PTR ?_CurrentDrive@@3EA, 4
	jb	SHORT $LN5@flpydsk_se

; 480  : 		return -1;

	or	eax, -1

; 499  : }

	pop	ecx
	ret	0
$LN5@flpydsk_se:
	push	ebx

; 481  : 
; 482  : 	for (int i = 0; i < 10; i++ ) {

	mov	ebx, DWORD PTR _cyl$[esp+4]
	push	edi
	xor	edi, edi
	shl	BYTE PTR _head$[esp+8], 2
	push	esi
	npad	3
$LL4@flpydsk_se:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL11@flpydsk_se:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN70@flpydsk_se

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL11@flpydsk_se

; 487  : 		flpydsk_send_command (cyl);
; 488  : 
; 489  : 		//! wait for the results phase IRQ
; 490  : 		flpydsk_wait_irq ();
; 491  : 		flpydsk_check_int (&st0,&cyl0);
; 492  : 
; 493  : 		//! found the cylinder?
; 494  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN10@flpydsk_se
$LN70@flpydsk_se:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	15					; 0000000fH
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN10@flpydsk_se:

; 483  : 
; 484  : 		//! send the command
; 485  : 		flpydsk_send_command (FDC_CMD_SEEK);
; 486  : 		flpydsk_send_command ( (head) << 2 | _CurrentDrive);

	mov	al, BYTE PTR _head$[esp+12]
	or	al, BYTE PTR ?_CurrentDrive@@3EA

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi

; 483  : 
; 484  : 		//! send the command
; 485  : 		flpydsk_send_command (FDC_CMD_SEEK);
; 486  : 		flpydsk_send_command ( (head) << 2 | _CurrentDrive);

	mov	BYTE PTR _cmd$[esp+16], al
	npad	3
$LL19@flpydsk_se:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN71@flpydsk_se

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL19@flpydsk_se

; 487  : 		flpydsk_send_command (cyl);
; 488  : 
; 489  : 		//! wait for the results phase IRQ
; 490  : 		flpydsk_wait_irq ();
; 491  : 		flpydsk_check_int (&st0,&cyl0);
; 492  : 
; 493  : 		//! found the cylinder?
; 494  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN18@flpydsk_se
$LN71@flpydsk_se:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	DWORD PTR _cmd$[esp+16]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN18@flpydsk_se:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL27@flpydsk_se:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN72@flpydsk_se

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL27@flpydsk_se

; 487  : 		flpydsk_send_command (cyl);
; 488  : 
; 489  : 		//! wait for the results phase IRQ
; 490  : 		flpydsk_wait_irq ();
; 491  : 		flpydsk_check_int (&st0,&cyl0);
; 492  : 
; 493  : 		//! found the cylinder?
; 494  : 		if ( cyl0 == cyl)

	jmp	SHORT $LL33@flpydsk_se
$LN72@flpydsk_se:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	npad	6
$LL33@flpydsk_se:

; 287  : 	while ( _FloppyDiskIRQ == 0)

	cmp	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	je	SHORT $LL33@flpydsk_se

; 288  : 		;
; 289  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL41@flpydsk_se:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN73@flpydsk_se

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL41@flpydsk_se

; 487  : 		flpydsk_send_command (cyl);
; 488  : 
; 489  : 		//! wait for the results phase IRQ
; 490  : 		flpydsk_wait_irq ();
; 491  : 		flpydsk_check_int (&st0,&cyl0);
; 492  : 
; 493  : 		//! found the cylinder?
; 494  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN40@flpydsk_se
$LN73@flpydsk_se:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	8
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN40@flpydsk_se:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL49@flpydsk_se:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN74@flpydsk_se

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL49@flpydsk_se

; 487  : 		flpydsk_send_command (cyl);
; 488  : 
; 489  : 		//! wait for the results phase IRQ
; 490  : 		flpydsk_wait_irq ();
; 491  : 		flpydsk_check_int (&st0,&cyl0);
; 492  : 
; 493  : 		//! found the cylinder?
; 494  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN48@flpydsk_se
$LN74@flpydsk_se:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN48@flpydsk_se:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	5
$LL57@flpydsk_se:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN75@flpydsk_se

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL57@flpydsk_se

; 268  : 
; 269  : 	return 0;

	xor	al, al
	jmp	SHORT $LN54@flpydsk_se
$LN75@flpydsk_se:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN54@flpydsk_se:

; 487  : 		flpydsk_send_command (cyl);
; 488  : 
; 489  : 		//! wait for the results phase IRQ
; 490  : 		flpydsk_wait_irq ();
; 491  : 		flpydsk_check_int (&st0,&cyl0);
; 492  : 
; 493  : 		//! found the cylinder?
; 494  : 		if ( cyl0 == cyl)

	cmp	al, bl
	je	SHORT $LN76@flpydsk_se

; 481  : 
; 482  : 	for (int i = 0; i < 10; i++ ) {

	inc	edi
	cmp	edi, 10					; 0000000aH
	jl	$LL4@flpydsk_se

; 496  : 	}
; 497  : 
; 498  : 	return -1;

	pop	esi
	pop	edi
	or	eax, -1
	pop	ebx

; 499  : }

	pop	ecx
	ret	0
$LN76@flpydsk_se:
	pop	esi
	pop	edi

; 495  : 			return 0;

	xor	eax, eax
	pop	ebx

; 499  : }

	pop	ecx
	ret	0
?flpydsk_seek@@YAHEE@Z ENDP				; flpydsk_seek
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_a$1 = -8						; size = 4
_c$2 = -4						; size = 4
_head$ = 8						; size = 1
_cmd$ = 8						; size = 1
_track$ = 12						; size = 1
_sector$ = 16						; size = 1
?flpydsk_read_sector_imp@@YAXEEE@Z PROC			; flpydsk_read_sector_imp

; 441  : void flpydsk_read_sector_imp (uint8_t head, uint8_t track, uint8_t sector) {

	sub	esp, 8
	push	esi

; 219  :    dma_reset (1);

	push	1
	mov	DWORD PTR _a$1[esp+16], 4096		; 00001000H
	mov	DWORD PTR _c$2[esp+16], 511		; 000001ffH
	call	?dma_reset@@YAXH@Z			; dma_reset

; 220  :    dma_mask_channel( FDC_DMA_CHANNEL );//Mask channel 2

	push	2
	call	?dma_mask_channel@@YAXE@Z		; dma_mask_channel

; 221  :    dma_reset_flipflop ( 1 );//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 222  : 
; 223  :    dma_set_address( FDC_DMA_CHANNEL, a.byte[0],a.byte[1]);//Buffer address

	push	16					; 00000010H
	push	0
	push	2
	call	?dma_set_address@@YAXEEE@Z		; dma_set_address

; 224  :    dma_reset_flipflop( 1 );//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 225  : 
; 226  :    dma_set_count( FDC_DMA_CHANNEL, c.byte[0],c.byte[1]);//Set count

	push	1
	push	255					; 000000ffH
	push	2
	call	?dma_set_count@@YAXEEE@Z		; dma_set_count

; 227  :    dma_set_read ( FDC_DMA_CHANNEL );

	push	2
	call	?dma_set_read@@YAXE@Z			; dma_set_read

; 228  : 
; 229  :    dma_unmask_all( 1 );//Unmask channel 2

	push	1
	call	?dma_unmask_all@@YAXH@Z			; dma_unmask_all

; 442  : 
; 443  : 	uint32_t st0, cyl;
; 444  : 
; 445  : 	//! initialize DMA
; 446  : 	dma_initialize_floppy ((uint8_t*) DMA_BUFFER, 512 );
; 447  : 
; 448  : 	//! set the DMA for read transfer
; 449  : 	dma_set_read ( FDC_DMA_CHANNEL );

	push	2
	call	?dma_set_read@@YAXE@Z			; dma_set_read
	add	esp, 52					; 00000034H

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL15@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN137@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL15@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN14@flpydsk_re
$LN137@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	230					; 000000e6H
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN14@flpydsk_re:
	push	ebx

; 450  : 
; 451  : 	//! read in a sector
; 452  : 	flpydsk_send_command (
; 453  : 				FDC_CMD_READ_SECT | FDC_CMD_EXT_MULTITRACK | FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);
; 454  : 	flpydsk_send_command ( head << 2 | _CurrentDrive );

	mov	ebx, DWORD PTR _head$[esp+12]
	mov	al, bl
	shl	al, 2
	or	al, BYTE PTR ?_CurrentDrive@@3EA

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	push	edi

; 450  : 
; 451  : 	//! read in a sector
; 452  : 	flpydsk_send_command (
; 453  : 				FDC_CMD_READ_SECT | FDC_CMD_EXT_MULTITRACK | FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);
; 454  : 	flpydsk_send_command ( head << 2 | _CurrentDrive );

	mov	BYTE PTR _cmd$[esp+16], al
	npad	8
$LL23@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN138@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL23@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN22@flpydsk_re
$LN138@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	DWORD PTR _cmd$[esp+16]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN22@flpydsk_re:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL31@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN139@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL31@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN30@flpydsk_re
$LN139@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	DWORD PTR _track$[esp+16]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN30@flpydsk_re:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL39@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN140@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL39@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN38@flpydsk_re
$LN140@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN38@flpydsk_re:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	4
$LL47@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	mov	ebx, DWORD PTR _sector$[esp+20]

; 242  : 	return inportb (FLPYDSK_MSR);

	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN141@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL47@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN46@flpydsk_re
$LN141@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN46@flpydsk_re:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL55@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN142@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL55@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN54@flpydsk_re
$LN142@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	2
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN54@flpydsk_re:

; 455  : 	flpydsk_send_command ( track);
; 456  : 	flpydsk_send_command ( head);
; 457  : 	flpydsk_send_command ( sector);
; 458  : 	flpydsk_send_command ( FLPYDSK_SECTOR_DTL_512 );
; 459  : 	flpydsk_send_command ( ( ( sector + 1 ) >= FLPY_SECTORS_PER_TRACK ) ? FLPY_SECTORS_PER_TRACK : sector + 1 );

	movzx	edi, bl
	mov	eax, 18					; 00000012H
	inc	edi
	cmp	edi, eax
	cmovae	edi, eax

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	5
$LL63@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN143@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL63@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN62@flpydsk_re
$LN143@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	edi
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN62@flpydsk_re:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	4
$LL71@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN144@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL71@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN70@flpydsk_re
$LN144@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	27					; 0000001bH
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN70@flpydsk_re:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	3
$LL79@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN145@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL79@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LL85@flpydsk_re
$LN145@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	255					; 000000ffH
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	npad	2
$LL85@flpydsk_re:

; 287  : 	while ( _FloppyDiskIRQ == 0)

	cmp	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	je	SHORT $LL85@flpydsk_re

; 288  : 		;
; 289  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	mov	edi, 7
	npad	11
$LL4@flpydsk_re:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL91@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN146@flpydsk_re

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL91@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN2@flpydsk_re
$LN146@flpydsk_re:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN2@flpydsk_re:

; 460  : 	flpydsk_send_command ( FLPYDSK_GAP3_LENGTH_3_5 );
; 461  : 	flpydsk_send_command ( 0xff );
; 462  : 
; 463  : 	//! wait for irq
; 464  : 	flpydsk_wait_irq ();
; 465  : 
; 466  : 	//! read status info
; 467  : 	for (int j=0; j<7; j++)

	sub	edi, 1
	jne	SHORT $LL4@flpydsk_re

; 256  : 	for (int i = 0; i < 500; i++ )

	pop	edi
	xor	esi, esi
	pop	ebx
$LL101@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN147@flpydsk_re

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL101@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN100@flpydsk_re
$LN147@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	8
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN100@flpydsk_re:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL109@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN148@flpydsk_re

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL109@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN108@flpydsk_re
$LN148@flpydsk_re:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN108@flpydsk_re:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	4
$LL117@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN149@flpydsk_re

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL117@flpydsk_re
	pop	esi

; 468  : 		flpydsk_read_data ();
; 469  : 
; 470  : 	//! let FDC know we handled interrupt
; 471  : 	flpydsk_check_int (&st0,&cyl);
; 472  : }

	add	esp, 8
	ret	0
$LN149@flpydsk_re:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
	pop	esi

; 468  : 		flpydsk_read_data ();
; 469  : 
; 470  : 	//! let FDC know we handled interrupt
; 471  : 	flpydsk_check_int (&st0,&cyl);
; 472  : }

	add	esp, 8
	ret	0
?flpydsk_read_sector_imp@@YAXEEE@Z ENDP			; flpydsk_read_sector_imp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
?flpydsk_reset@@YAXXZ PROC				; flpydsk_reset

; 249  : 	outportb (FLPYDSK_DOR, val);

	push	0
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	12					; 0000000cH
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 16					; 00000010H
	npad	5
$LL15@flpydsk_re:

; 287  : 	while ( _FloppyDiskIRQ == 0)

	cmp	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	je	SHORT $LL15@flpydsk_re

; 288  : 		;
; 289  : 	_FloppyDiskIRQ = 0;

	push	esi
	push	edi
	mov	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	mov	edi, 4
	npad	9
$LL4@flpydsk_re:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL23@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN51@flpydsk_re

; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL23@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN22@flpydsk_re
$LN51@flpydsk_re:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	8
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN22@flpydsk_re:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL31@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN52@flpydsk_re

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL31@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN30@flpydsk_re
$LN52@flpydsk_re:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN30@flpydsk_re:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	5
$LL39@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN53@flpydsk_re

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL39@flpydsk_re

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN38@flpydsk_re
$LN53@flpydsk_re:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN38@flpydsk_re:

; 418  : 
; 419  : 	uint32_t st0, cyl;
; 420  : 
; 421  : 	//! reset the controller
; 422  : 	flpydsk_disable_controller ();
; 423  : 	flpydsk_enable_controller ();
; 424  : 	flpydsk_wait_irq ();
; 425  : 
; 426  : 	//! send CHECK_INT/SENSE INTERRUPT command to all drives
; 427  : 	for (int i=0; i<4; i++)

	sub	edi, 1
	jne	$LL4@flpydsk_re

; 276  : 	outportb (FLPYDSK_CTRL, val);

	push	edi
	push	1015					; 000003f7H
	call	?outportb@@YAXGE@Z			; outportb

; 428  : 		flpydsk_check_int (&st0,&cyl);
; 429  : 
; 430  : 	//! transfer speed 500kb/s
; 431  : 	flpydsk_write_ccr (0);
; 432  : 
; 433  : 	//! pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
; 434  : 	flpydsk_drive_data (3,16,240,true);

	push	1
	push	240					; 000000f0H
	push	16					; 00000010H
	push	3
	call	?flpydsk_drive_data@@YAXEEE_N@Z		; flpydsk_drive_data

; 435  : 
; 436  : 	//! calibrate the disk
; 437  : 	flpydsk_calibrate ( _CurrentDrive );

	movzx	eax, BYTE PTR ?_CurrentDrive@@3EA
	push	eax
	call	?flpydsk_calibrate@@YAHE@Z		; flpydsk_calibrate
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 438  : }

	ret	0
?flpydsk_reset@@YAXXZ ENDP				; flpydsk_reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
?flpydsk_enable_controller@@YAXXZ PROC			; flpydsk_enable_controller

; 249  : 	outportb (FLPYDSK_DOR, val);

	push	12					; 0000000cH
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 412  : 
; 413  : 	flpydsk_write_dor ( FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA);
; 414  : }

	ret	0
?flpydsk_enable_controller@@YAXXZ ENDP			; flpydsk_enable_controller
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
?flpydsk_disable_controller@@YAXXZ PROC			; flpydsk_disable_controller

; 249  : 	outportb (FLPYDSK_DOR, val);

	push	0
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 406  : 
; 407  : 	flpydsk_write_dor (0);
; 408  : }

	ret	0
?flpydsk_disable_controller@@YAXXZ ENDP			; flpydsk_disable_controller
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_drive$ = 8						; size = 1
$T1 = 8							; size = 1
?flpydsk_calibrate@@YAHE@Z PROC				; flpydsk_calibrate

; 374  : int flpydsk_calibrate (uint8_t drive) {

	push	ebx

; 375  : 
; 376  : 	uint32_t st0, cyl;
; 377  : 
; 378  : 	if (drive >= 4)

	mov	ebx, DWORD PTR _drive$[esp]
	cmp	bl, 4
	jb	SHORT $LN5@flpydsk_ca

; 379  : 		return -2;

	mov	eax, -2					; fffffffeH
	pop	ebx

; 402  : }

	ret	0
$LN5@flpydsk_ca:

; 328  : 	if (_CurrentDrive > 3)

	mov	al, BYTE PTR ?_CurrentDrive@@3EA
	cmp	al, 3
	ja	SHORT $LN8@flpydsk_ca

; 329  : 		return;
; 330  : 
; 331  : 	uint8_t motor = 0;
; 332  : 
; 333  : 	//! select the correct mask based on current drive
; 334  : 	switch (_CurrentDrive) {

	movzx	edx, al
	xor	cl, cl
	cmp	edx, 3
	ja	SHORT $LN9@flpydsk_ca
	jmp	DWORD PTR $LN181@flpydsk_ca[edx*4]
$LN12@flpydsk_ca:

; 335  : 
; 336  : 		case 0:
; 337  : 			motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;

	mov	cl, 16					; 00000010H

; 338  : 			break;

	jmp	SHORT $LN9@flpydsk_ca
$LN13@flpydsk_ca:

; 339  : 		case 1:
; 340  : 			motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;

	mov	cl, 32					; 00000020H

; 341  : 			break;

	jmp	SHORT $LN9@flpydsk_ca
$LN14@flpydsk_ca:

; 342  : 		case 2:
; 343  : 			motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;

	mov	cl, 64					; 00000040H

; 344  : 			break;

	jmp	SHORT $LN9@flpydsk_ca
$LN15@flpydsk_ca:

; 345  : 		case 3:
; 346  : 			motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;

	mov	cl, 128					; 00000080H
$LN9@flpydsk_ca:

; 347  : 			break;
; 348  : 	}
; 349  : 
; 350  : 	//! turn on or off the motor of that drive
; 351  : 	if (b)
; 352  : 		flpydsk_write_dor (uint8_t(_CurrentDrive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));

	or	al, cl
	or	al, 12					; 0000000cH

; 249  : 	outportb (FLPYDSK_DOR, val);

	mov	BYTE PTR $T1[esp], al

; 357  : 	sleep (20);

	push	DWORD PTR $T1[esp]
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN8@flpydsk_ca:
	push	edi

; 380  : 
; 381  : 	//! turn on the motor
; 382  : 	flpydsk_control_motor (true);
; 383  : 
; 384  : 	for (int i = 0; i < 10; i++) {

	xor	edi, edi
	push	esi
	npad	3
$LL4@flpydsk_ca:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL26@flpydsk_ca:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN106@flpydsk_ca

; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL26@flpydsk_ca

; 385  : 
; 386  : 		//! send command
; 387  : 		flpydsk_send_command ( FDC_CMD_CALIBRATE );
; 388  : 		flpydsk_send_command ( drive );
; 389  : 		flpydsk_wait_irq ();
; 390  : 		flpydsk_check_int ( &st0, &cyl);
; 391  : 
; 392  : 		//! did we fine cylinder 0? if so, we are done
; 393  : 		if (!cyl) {

	jmp	SHORT $LN25@flpydsk_ca
$LN106@flpydsk_ca:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	7
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN25@flpydsk_ca:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL34@flpydsk_ca:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN107@flpydsk_ca

; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL34@flpydsk_ca

; 385  : 
; 386  : 		//! send command
; 387  : 		flpydsk_send_command ( FDC_CMD_CALIBRATE );
; 388  : 		flpydsk_send_command ( drive );
; 389  : 		flpydsk_wait_irq ();
; 390  : 		flpydsk_check_int ( &st0, &cyl);
; 391  : 
; 392  : 		//! did we fine cylinder 0? if so, we are done
; 393  : 		if (!cyl) {

	jmp	SHORT $LL40@flpydsk_ca
$LN107@flpydsk_ca:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	npad	6
$LL40@flpydsk_ca:

; 287  : 	while ( _FloppyDiskIRQ == 0)

	cmp	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	je	SHORT $LL40@flpydsk_ca

; 288  : 		;
; 289  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL48@flpydsk_ca:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN108@flpydsk_ca

; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL48@flpydsk_ca

; 385  : 
; 386  : 		//! send command
; 387  : 		flpydsk_send_command ( FDC_CMD_CALIBRATE );
; 388  : 		flpydsk_send_command ( drive );
; 389  : 		flpydsk_wait_irq ();
; 390  : 		flpydsk_check_int ( &st0, &cyl);
; 391  : 
; 392  : 		//! did we fine cylinder 0? if so, we are done
; 393  : 		if (!cyl) {

	jmp	SHORT $LN47@flpydsk_ca
$LN108@flpydsk_ca:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	8
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN47@flpydsk_ca:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL56@flpydsk_ca:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN109@flpydsk_ca

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL56@flpydsk_ca

; 385  : 
; 386  : 		//! send command
; 387  : 		flpydsk_send_command ( FDC_CMD_CALIBRATE );
; 388  : 		flpydsk_send_command ( drive );
; 389  : 		flpydsk_wait_irq ();
; 390  : 		flpydsk_check_int ( &st0, &cyl);
; 391  : 
; 392  : 		//! did we fine cylinder 0? if so, we are done
; 393  : 		if (!cyl) {

	jmp	SHORT $LN55@flpydsk_ca
$LN109@flpydsk_ca:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN55@flpydsk_ca:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	5
$LL64@flpydsk_ca:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN110@flpydsk_ca

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL64@flpydsk_ca
$LN111@flpydsk_ca:

; 328  : 	if (_CurrentDrive > 3)

	cmp	BYTE PTR ?_CurrentDrive@@3EA, 3
	ja	SHORT $LN69@flpydsk_ca

; 353  : 	else
; 354  : 		flpydsk_write_dor (FLPYDSK_DOR_MASK_RESET);
; 355  : 
; 356  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 357  : 	sleep (20);

	push	4
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN69@flpydsk_ca:
	pop	esi
	pop	edi

; 394  : 
; 395  : 			flpydsk_control_motor (false);
; 396  : 			return 0;

	xor	eax, eax
	pop	ebx

; 402  : }

	ret	0
$LN110@flpydsk_ca:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 385  : 
; 386  : 		//! send command
; 387  : 		flpydsk_send_command ( FDC_CMD_CALIBRATE );
; 388  : 		flpydsk_send_command ( drive );
; 389  : 		flpydsk_wait_irq ();
; 390  : 		flpydsk_check_int ( &st0, &cyl);
; 391  : 
; 392  : 		//! did we fine cylinder 0? if so, we are done
; 393  : 		if (!cyl) {

	test	al, al
	je	SHORT $LN111@flpydsk_ca

; 380  : 
; 381  : 	//! turn on the motor
; 382  : 	flpydsk_control_motor (true);
; 383  : 
; 384  : 	for (int i = 0; i < 10; i++) {

	inc	edi
	cmp	edi, 10					; 0000000aH
	jl	$LL4@flpydsk_ca

; 328  : 	if (_CurrentDrive > 3)

	cmp	BYTE PTR ?_CurrentDrive@@3EA, 3
	ja	SHORT $LN84@flpydsk_ca

; 353  : 	else
; 354  : 		flpydsk_write_dor (FLPYDSK_DOR_MASK_RESET);
; 355  : 
; 356  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 357  : 	sleep (20);

	push	4
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN84@flpydsk_ca:
	pop	esi
	pop	edi

; 397  : 		}
; 398  : 	}
; 399  : 
; 400  : 	flpydsk_control_motor (false);
; 401  : 	return -1;

	or	eax, -1
	pop	ebx

; 402  : }

	ret	0
$LN181@flpydsk_ca:
	DD	$LN12@flpydsk_ca
	DD	$LN13@flpydsk_ca
	DD	$LN14@flpydsk_ca
	DD	$LN15@flpydsk_ca
?flpydsk_calibrate@@YAHE@Z ENDP				; flpydsk_calibrate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 1
_stepr$ = 8						; size = 1
_loadt$ = 12						; size = 1
_unloadt$ = 16						; size = 1
_dma$ = 20						; size = 1
?flpydsk_drive_data@@YAXEEE_N@Z PROC			; flpydsk_drive_data

; 361  : void flpydsk_drive_data (uint8_t stepr, uint8_t loadt, uint8_t unloadt, bool dma ) {

	push	esi

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL6@flpydsk_dr:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN30@flpydsk_dr

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL6@flpydsk_dr

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN5@flpydsk_dr
$LN30@flpydsk_dr:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	3
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN5@flpydsk_dr:

; 362  : 
; 363  : 	uint8_t data = 0;
; 364  : 
; 365  : 	//! send command
; 366  : 	flpydsk_send_command (FDC_CMD_SPECIFY);
; 367  : 	data = ( (stepr & 0xf) << 4) | (unloadt & 0xf);

	mov	cl, BYTE PTR _stepr$[esp]
	mov	al, BYTE PTR _unloadt$[esp]
	shl	cl, 4
	and	al, 15					; 0000000fH
	or	cl, al

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi

; 362  : 
; 363  : 	uint8_t data = 0;
; 364  : 
; 365  : 	//! send command
; 366  : 	flpydsk_send_command (FDC_CMD_SPECIFY);
; 367  : 	data = ( (stepr & 0xf) << 4) | (unloadt & 0xf);

	mov	BYTE PTR _data$[esp], cl
$LL14@flpydsk_dr:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN31@flpydsk_dr

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL14@flpydsk_dr

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN13@flpydsk_dr
$LN31@flpydsk_dr:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	DWORD PTR _data$[esp]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN13@flpydsk_dr:

; 368  : 		flpydsk_send_command (data);
; 369  : 	data = (( loadt << 1 ) | ( (dma) ? 0 : 1 ) );

	mov	cl, BYTE PTR _loadt$[esp]
	mov	al, BYTE PTR _dma$[esp]
	add	cl, cl
	xor	al, 1
	or	cl, al

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi

; 368  : 		flpydsk_send_command (data);
; 369  : 	data = (( loadt << 1 ) | ( (dma) ? 0 : 1 ) );

	mov	BYTE PTR _data$[esp], cl
$LL22@flpydsk_dr:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN32@flpydsk_dr

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL22@flpydsk_dr
	pop	esi

; 370  : 		flpydsk_send_command (data);
; 371  : }

	ret	0
$LN32@flpydsk_dr:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	DWORD PTR _data$[esp]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	pop	esi

; 370  : 		flpydsk_send_command (data);
; 371  : }

	ret	0
?flpydsk_drive_data@@YAXEEE_N@Z ENDP			; flpydsk_drive_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 1
_b$ = 8							; size = 1
?flpydsk_control_motor@@YAX_N@Z PROC			; flpydsk_control_motor

; 325  : void flpydsk_control_motor (bool b) {

	push	ecx

; 326  : 
; 327  : 	//! sanity check: invalid drive
; 328  : 	if (_CurrentDrive > 3)

	mov	al, BYTE PTR ?_CurrentDrive@@3EA
	cmp	al, 3
	ja	SHORT $LN1@flpydsk_co

; 329  : 		return;
; 330  : 
; 331  : 	uint8_t motor = 0;
; 332  : 
; 333  : 	//! select the correct mask based on current drive
; 334  : 	switch (_CurrentDrive) {

	movzx	edx, al
	xor	cl, cl
	cmp	edx, 3
	ja	SHORT $LN2@flpydsk_co
	jmp	DWORD PTR $LN19@flpydsk_co[edx*4]
$LN5@flpydsk_co:

; 335  : 
; 336  : 		case 0:
; 337  : 			motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;

	mov	cl, 16					; 00000010H

; 338  : 			break;

	jmp	SHORT $LN2@flpydsk_co
$LN6@flpydsk_co:

; 339  : 		case 1:
; 340  : 			motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;

	mov	cl, 32					; 00000020H

; 341  : 			break;

	jmp	SHORT $LN2@flpydsk_co
$LN7@flpydsk_co:

; 342  : 		case 2:
; 343  : 			motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;

	mov	cl, 64					; 00000040H

; 344  : 			break;

	jmp	SHORT $LN2@flpydsk_co
$LN8@flpydsk_co:

; 345  : 		case 3:
; 346  : 			motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;

	mov	cl, 128					; 00000080H
$LN2@flpydsk_co:

; 347  : 			break;
; 348  : 	}
; 349  : 
; 350  : 	//! turn on or off the motor of that drive
; 351  : 	if (b)

	cmp	BYTE PTR _b$[esp], 0
	je	SHORT $LN9@flpydsk_co

; 352  : 		flpydsk_write_dor (uint8_t(_CurrentDrive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));

	or	al, cl
	or	al, 12					; 0000000cH

; 249  : 	outportb (FLPYDSK_DOR, val);

	mov	BYTE PTR $T1[esp+4], al

; 353  : 	else

	jmp	SHORT $LN10@flpydsk_co
$LN9@flpydsk_co:

; 249  : 	outportb (FLPYDSK_DOR, val);

	mov	BYTE PTR $T1[esp+4], 4
$LN10@flpydsk_co:

; 354  : 		flpydsk_write_dor (FLPYDSK_DOR_MASK_RESET);
; 355  : 
; 356  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 357  : 	sleep (20);

	push	DWORD PTR $T1[esp+4]
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb

; 358  : }

	add	esp, 12					; 0000000cH

; 354  : 		flpydsk_write_dor (FLPYDSK_DOR_MASK_RESET);
; 355  : 
; 356  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 357  : 	sleep (20);

	mov	DWORD PTR _b$[esp-4], 20		; 00000014H
	jmp	?sleep@@YAXH@Z				; sleep
$LN1@flpydsk_co:

; 358  : }

	pop	ecx
	ret	0
$LN19@flpydsk_co:
	DD	$LN5@flpydsk_co
	DD	$LN6@flpydsk_co
	DD	$LN7@flpydsk_co
	DD	$LN8@flpydsk_co
?flpydsk_control_motor@@YAX_N@Z ENDP			; flpydsk_control_motor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_st0$ = 8						; size = 4
_cyl$ = 12						; size = 4
?flpydsk_check_int@@YAXPAI0@Z PROC			; flpydsk_check_int

; 316  : void flpydsk_check_int (uint32_t* st0, uint32_t* cyl) {

	push	esi

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL6@flpydsk_ch:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN30@flpydsk_ch

; 243  : }
; 244  : 
; 245  : //! write to the fdc dor
; 246  : void flpydsk_write_dor (uint8_t val ) {
; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);
; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL6@flpydsk_ch

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN5@flpydsk_ch
$LN30@flpydsk_ch:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	8
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN5@flpydsk_ch:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL14@flpydsk_ch:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN31@flpydsk_ch

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL14@flpydsk_ch

; 268  : 
; 269  : 	return 0;

	xor	al, al
	jmp	SHORT $LN11@flpydsk_ch
$LN31@flpydsk_ch:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN11@flpydsk_ch:

; 317  : 
; 318  : 	flpydsk_send_command (FDC_CMD_CHECK_INT);
; 319  : 
; 320  : 	*st0 = flpydsk_read_data ();

	movzx	ecx, al

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi

; 317  : 
; 318  : 	flpydsk_send_command (FDC_CMD_CHECK_INT);
; 319  : 
; 320  : 	*st0 = flpydsk_read_data ();

	mov	eax, DWORD PTR _st0$[esp]
	mov	DWORD PTR [eax], ecx
$LL22@flpydsk_ch:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN32@flpydsk_ch

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL22@flpydsk_ch

; 268  : 
; 269  : 	return 0;

	xor	al, al

; 321  : 	*cyl = flpydsk_read_data ();

	movzx	ecx, al
	mov	eax, DWORD PTR _cyl$[esp]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 322  : }

	ret	0
$LN32@flpydsk_ch:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb

; 321  : 	*cyl = flpydsk_read_data ();

	movzx	ecx, al

; 267  : 			return inportb (FLPYDSK_FIFO);

	add	esp, 4

; 321  : 	*cyl = flpydsk_read_data ();

	mov	eax, DWORD PTR _cyl$[esp]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 322  : }

	ret	0
?flpydsk_check_int@@YAXPAI0@Z ENDP			; flpydsk_check_int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
?i86_flpy_irq@@YAXXZ PROC				; i86_flpy_irq

; 294  : void _cdecl i86_flpy_irq () {

	push	ebx
	push	esi
	push	edi

; 295  : 
; 296  : 	_asm add esp, 12

	add	esp, 12					; 0000000cH
	pushad
	cli
	mov	BYTE PTR ?_FloppyDiskIRQ@@3EC, 1

; 297  : 	_asm pushad
; 298  : 	_asm cli
; 299  : 
; 300  : 	//! irq fired
; 301  : 	_FloppyDiskIRQ = 1;
; 302  : 
; 303  : 	//! tell hal we are done
; 304  : 	interruptdone( FLOPPY_IRQ );

	push	6
	call	?interruptdone@@YAXI@Z			; interruptdone
	add	esp, 4

; 305  : 
; 306  : 	_asm sti

	sti
	popad
	iretd
	pop	edi
	pop	esi
	pop	ebx
	ret	0
?i86_flpy_irq@@YAXXZ ENDP				; i86_flpy_irq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
;	COMDAT ?flpydsk_wait_irq@@YAXXZ
_TEXT	SEGMENT
?flpydsk_wait_irq@@YAXXZ PROC				; flpydsk_wait_irq, COMDAT

; 284  : inline void flpydsk_wait_irq () {

$LL2@flpydsk_wa:

; 285  : 
; 286  : 	//! wait for irq to fire
; 287  : 	while ( _FloppyDiskIRQ == 0)

	cmp	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	je	SHORT $LL2@flpydsk_wa

; 288  : 		;
; 289  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0

; 290  : }

	ret	0
?flpydsk_wait_irq@@YAXXZ ENDP				; flpydsk_wait_irq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 1
?flpydsk_write_ccr@@YAXE@Z PROC				; flpydsk_write_ccr

; 274  : 
; 275  : 	//! write the configuation control
; 276  : 	outportb (FLPYDSK_CTRL, val);

	push	DWORD PTR _val$[esp-4]
	push	1015					; 000003f7H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 277  : }

	ret	0
?flpydsk_write_ccr@@YAXE@Z ENDP				; flpydsk_write_ccr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
?flpydsk_read_data@@YAEXZ PROC				; flpydsk_read_data

; 262  : uint8_t flpydsk_read_data () {

	push	esi

; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL4@flpydsk_re:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN10@flpydsk_re

; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL4@flpydsk_re

; 268  : 
; 269  : 	return 0;

	xor	al, al
	pop	esi

; 270  : }

	ret	0
$LN10@flpydsk_re:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
	pop	esi

; 270  : }

	ret	0
?flpydsk_read_data@@YAEXZ ENDP				; flpydsk_read_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_cmd$ = 8						; size = 1
?flpydsk_send_command@@YAXE@Z PROC			; flpydsk_send_command

; 253  : void flpydsk_send_command (uint8_t cmd) {

	push	esi

; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL4@flpydsk_se:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN10@flpydsk_se

; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL4@flpydsk_se
	pop	esi

; 259  : }

	ret	0
$LN10@flpydsk_se:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	DWORD PTR _cmd$[esp]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	pop	esi

; 259  : }

	ret	0
?flpydsk_send_command@@YAXE@Z ENDP			; flpydsk_send_command
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 1
?flpydsk_write_dor@@YAXE@Z PROC				; flpydsk_write_dor

; 247  : 
; 248  : 	//! write the digital output register
; 249  : 	outportb (FLPYDSK_DOR, val);

	push	DWORD PTR _val$[esp-4]
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 250  : }

	ret	0
?flpydsk_write_dor@@YAXE@Z ENDP				; flpydsk_write_dor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
?flpydsk_read_status@@YAEXZ PROC			; flpydsk_read_status

; 240  : 
; 241  : 	//! just return main status register
; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 243  : }

	ret	0
?flpydsk_read_status@@YAEXZ ENDP			; flpydsk_read_status
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_c$ = -8						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?dma_initialize_floppy@@YA_NPAEI@Z PROC			; dma_initialize_floppy

; 198  : bool _cdecl dma_initialize_floppy(uint8_t* buffer, unsigned length){

	sub	esp, 8
	push	esi

; 199  :    union{
; 200  :       uint8_t byte[4];//Lo[0], Mid[1], Hi[2]
; 201  :       unsigned long l;
; 202  :    }a, c;
; 203  : 
; 204  :    a.l=(unsigned)buffer;
; 205  :    c.l=(unsigned)length-1;

	mov	esi, DWORD PTR _length$[esp+8]
	push	edi

; 206  : 
; 207  :    //Check for buffer issues
; 208  :    if ((a.l >> 24) || (c.l >> 16) || (((a.l & 0xffff)+c.l) >> 16)){

	mov	edi, DWORD PTR _buffer$[esp+12]
	dec	esi
	mov	DWORD PTR _c$[esp+16], esi
	cmp	edi, 16777216				; 01000000H
	jae	SHORT $LN3@dma_initia
	test	esi, -65536				; ffff0000H
	jne	SHORT $LN3@dma_initia
	movzx	eax, di
	add	eax, esi
	test	eax, -65536				; ffff0000H
	jne	SHORT $LN3@dma_initia

; 217  :    }
; 218  : 
; 219  :    dma_reset (1);

	push	1
	call	?dma_reset@@YAXH@Z			; dma_reset

; 220  :    dma_mask_channel( FDC_DMA_CHANNEL );//Mask channel 2

	push	2
	call	?dma_mask_channel@@YAXE@Z		; dma_mask_channel

; 221  :    dma_reset_flipflop ( 1 );//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 222  : 
; 223  :    dma_set_address( FDC_DMA_CHANNEL, a.byte[0],a.byte[1]);//Buffer address

	push	DWORD PTR _buffer$[esp+25]
	push	edi
	push	2
	call	?dma_set_address@@YAXEEE@Z		; dma_set_address

; 224  :    dma_reset_flipflop( 1 );//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 225  : 
; 226  :    dma_set_count( FDC_DMA_CHANNEL, c.byte[0],c.byte[1]);//Set count

	push	DWORD PTR _c$[esp+45]
	push	esi
	push	2
	call	?dma_set_count@@YAXEEE@Z		; dma_set_count

; 227  :    dma_set_read ( FDC_DMA_CHANNEL );

	push	2
	call	?dma_set_read@@YAXE@Z			; dma_set_read

; 228  : 
; 229  :    dma_unmask_all( 1 );//Unmask channel 2

	push	1
	call	?dma_unmask_all@@YAXH@Z			; dma_unmask_all
	add	esp, 48					; 00000030H

; 230  : 
; 231  :    return true;

	mov	al, 1
	pop	edi

; 232  : }

	pop	esi
	add	esp, 8
	ret	0
$LN3@dma_initia:
	pop	edi

; 209  : #ifdef _DEBUG
; 210  :       _asm{
; 211  :          mov      eax, 0x1337
; 212  :          cli
; 213  :          hlt
; 214  :       }
; 215  : #endif
; 216  :       return false;

	xor	al, al

; 232  : }

	pop	esi
	add	esp, 8
	ret	0
?dma_initialize_floppy@@YA_NPAEI@Z ENDP			; dma_initialize_floppy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_lba$ = 8						; size = 4
_head$ = 12						; size = 4
_track$ = 16						; size = 4
_sector$ = 20						; size = 4
?flpydsk_lba_to_chs@@YAXHPAH00@Z PROC			; flpydsk_lba_to_chs

; 506  : void flpydsk_lba_to_chs (int lba,int *head,int *track,int *sector) {

	push	ebx

; 507  : 
; 508  :    *head = ( lba % ( FLPY_SECTORS_PER_TRACK * 2 ) ) / ( FLPY_SECTORS_PER_TRACK );

	mov	ebx, DWORD PTR _lba$[esp]
	mov	eax, 954437177				; 38e38e39H
	imul	ebx
	push	esi
	sar	edx, 3
	mov	ecx, ebx
	push	edi
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	lea	eax, DWORD PTR [edi+edi*8]
	shl	eax, 2
	sub	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	mov	ecx, DWORD PTR _head$[esp+8]

; 509  :    *track = lba / ( FLPY_SECTORS_PER_TRACK * 2 );
; 510  :    *sector = lba % FLPY_SECTORS_PER_TRACK + 1;

	mov	eax, 954437177				; 38e38e39H
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	imul	ebx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR _track$[esp+8]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [ecx], edi
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, eax
	sub	ebx, eax
	mov	eax, DWORD PTR _sector$[esp]
	inc	ebx
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 511  : }

	ret	0
?flpydsk_lba_to_chs@@YAXHPAH00@Z ENDP			; flpydsk_lba_to_chs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 1
_head$1$ = -8						; size = 4
tv223 = -4						; size = 4
_track$1$ = -4						; size = 4
_sectorLBA$ = 8						; size = 4
?flpydsk_read_sector@@YAPAEH@Z PROC			; flpydsk_read_sector

; 540  : uint8_t* flpydsk_read_sector (int sectorLBA) {

	sub	esp, 12					; 0000000cH
	push	ebx

; 541  : 
; 542  : 	if (_CurrentDrive >= 4)

	mov	bl, BYTE PTR ?_CurrentDrive@@3EA
	cmp	bl, 4
	jb	SHORT $LN2@flpydsk_re

; 543  : 		return 0;

	xor	eax, eax
	pop	ebx

; 560  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@flpydsk_re:
	push	esi

; 508  :    *head = ( lba % ( FLPY_SECTORS_PER_TRACK * 2 ) ) / ( FLPY_SECTORS_PER_TRACK );

	mov	esi, DWORD PTR _sectorLBA$[esp+16]
	mov	eax, 954437177				; 38e38e39H
	imul	esi
	mov	ecx, esi
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _track$1$[esp+20], eax
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	sub	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _head$1$[esp+20], eax

; 509  :    *track = lba / ( FLPY_SECTORS_PER_TRACK * 2 );
; 510  :    *sector = lba % FLPY_SECTORS_PER_TRACK + 1;

	mov	eax, 954437177				; 38e38e39H
	imul	esi
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, eax
	sub	esi, eax
	inc	esi

; 328  : 	if (_CurrentDrive > 3)

	cmp	bl, 3
	ja	SHORT $LN7@flpydsk_re

; 329  : 		return;
; 330  : 
; 331  : 	uint8_t motor = 0;
; 332  : 
; 333  : 	//! select the correct mask based on current drive
; 334  : 	switch (_CurrentDrive) {

	movzx	ecx, bl
	xor	al, al
	cmp	ecx, 3
	ja	SHORT $LN8@flpydsk_re
	jmp	DWORD PTR $LN39@flpydsk_re[ecx*4]
$LN11@flpydsk_re:

; 335  : 
; 336  : 		case 0:
; 337  : 			motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;

	mov	al, 16					; 00000010H

; 338  : 			break;

	jmp	SHORT $LN8@flpydsk_re
$LN12@flpydsk_re:

; 339  : 		case 1:
; 340  : 			motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;

	mov	al, 32					; 00000020H

; 341  : 			break;

	jmp	SHORT $LN8@flpydsk_re
$LN13@flpydsk_re:

; 342  : 		case 2:
; 343  : 			motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;

	mov	al, 64					; 00000040H

; 344  : 			break;

	jmp	SHORT $LN8@flpydsk_re
$LN14@flpydsk_re:

; 345  : 		case 3:
; 346  : 			motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;

	mov	al, 128					; 00000080H
$LN8@flpydsk_re:

; 347  : 			break;
; 348  : 	}
; 349  : 
; 350  : 	//! turn on or off the motor of that drive
; 351  : 	if (b)
; 352  : 		flpydsk_write_dor (uint8_t(_CurrentDrive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));

	or	bl, al
	or	bl, 12					; 0000000cH

; 249  : 	outportb (FLPYDSK_DOR, val);

	mov	BYTE PTR $T1[esp+20], bl

; 357  : 	sleep (20);

	push	DWORD PTR $T1[esp+20]
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN7@flpydsk_re:

; 544  : 
; 545  : 	//! convert LBA sector to CHS
; 546  : 	int head=0, track=0, sector=1;
; 547  : 	flpydsk_lba_to_chs (sectorLBA, &head, &track, &sector);
; 548  : 
; 549  : 	//! turn motor on and seek to track
; 550  : 	flpydsk_control_motor (true);
; 551  : 	if (flpydsk_seek ((uint8_t)track, (uint8_t)head) != 0)

	mov	bl, BYTE PTR _head$1$[esp+20]
	mov	al, BYTE PTR _track$1$[esp+20]
	push	ebx
	push	eax
	mov	DWORD PTR tv223[esp+28], eax
	call	?flpydsk_seek@@YAHEE@Z			; flpydsk_seek
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@flpydsk_re

; 552  : 		return 0;

	pop	esi
	xor	eax, eax
	pop	ebx

; 560  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN3@flpydsk_re:

; 553  : 
; 554  : 	//! read sector and turn motor off
; 555  : 	flpydsk_read_sector_imp ((uint8_t)head, (uint8_t)track, (uint8_t)sector);

	push	esi
	push	DWORD PTR tv223[esp+24]
	push	ebx
	call	?flpydsk_read_sector_imp@@YAXEEE@Z	; flpydsk_read_sector_imp
	add	esp, 12					; 0000000cH

; 328  : 	if (_CurrentDrive > 3)

	cmp	BYTE PTR ?_CurrentDrive@@3EA, 3
	ja	SHORT $LN22@flpydsk_re

; 353  : 	else
; 354  : 		flpydsk_write_dor (FLPYDSK_DOR_MASK_RESET);
; 355  : 
; 356  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 357  : 	sleep (20);

	push	4
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN22@flpydsk_re:
	pop	esi

; 556  : 	flpydsk_control_motor (false);
; 557  : 
; 558  : 	//! warning: this is a bit hackish
; 559  : 	return (uint8_t*) DMA_BUFFER;

	mov	eax, 4096				; 00001000H
	pop	ebx

; 560  : }

	add	esp, 12					; 0000000cH
	ret	0
	npad	1
$LN39@flpydsk_re:
	DD	$LN11@flpydsk_re
	DD	$LN12@flpydsk_re
	DD	$LN13@flpydsk_re
	DD	$LN14@flpydsk_re
?flpydsk_read_sector@@YAPAEH@Z ENDP			; flpydsk_read_sector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
?flpydsk_get_working_drive@@YAEXZ PROC			; flpydsk_get_working_drive

; 535  : 
; 536  : 	return _CurrentDrive;

	mov	al, BYTE PTR ?_CurrentDrive@@3EA

; 537  : }

	ret	0
?flpydsk_get_working_drive@@YAEXZ ENDP			; flpydsk_get_working_drive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_drive$ = 8						; size = 1
?flpydsk_set_working_drive@@YAXE@Z PROC			; flpydsk_set_working_drive

; 528  : 
; 529  : 	if (drive < 4)

	movzx	edx, BYTE PTR ?_CurrentDrive@@3EA
	cmp	BYTE PTR _drive$[esp-4], 4
	movzx	ecx, BYTE PTR _drive$[esp-4]
	cmovb	edx, ecx
	mov	BYTE PTR ?_CurrentDrive@@3EA, dl

; 530  : 		_CurrentDrive = drive;
; 531  : }

	ret	0
?flpydsk_set_working_drive@@YAXE@Z ENDP			; flpydsk_set_working_drive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\b54275\desktop\lab3-oper\demo25\syscore\floppydisk\flpydsk.cpp
_TEXT	SEGMENT
_irq$ = 8						; size = 4
?flpydsk_install@@YAXH@Z PROC				; flpydsk_install

; 515  : 
; 516  : 	//! install irq handler
; 517  : 	setvect (irq, i86_flpy_irq);

	push	0
	push	OFFSET ?i86_flpy_irq@@YAXXZ		; i86_flpy_irq
	push	DWORD PTR _irq$[esp+4]
	call	?setvect@@YAXHA6AXXZH@Z			; setvect

; 249  : 	outportb (FLPYDSK_DOR, val);

	push	0
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	12					; 0000000cH
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 28					; 0000001cH
	npad	5
$LL17@flpydsk_in:

; 287  : 	while ( _FloppyDiskIRQ == 0)

	cmp	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	je	SHORT $LL17@flpydsk_in

; 288  : 		;
; 289  : 	_FloppyDiskIRQ = 0;

	push	esi
	push	edi
	mov	BYTE PTR ?_FloppyDiskIRQ@@3EC, 0
	mov	edi, 4
	npad	9
$LL6@flpydsk_in:

; 256  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL25@flpydsk_in:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 257  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN53@flpydsk_in

; 250  : }
; 251  : 
; 252  : //! send command byte to fdc
; 253  : void flpydsk_send_command (uint8_t cmd) {
; 254  : 
; 255  : 	//! wait until data register is ready. We send commands to the data register
; 256  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL25@flpydsk_in

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN24@flpydsk_in
$LN53@flpydsk_in:

; 258  : 			return outportb (FLPYDSK_FIFO, cmd);

	push	8
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN24@flpydsk_in:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	1
$LL33@flpydsk_in:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN54@flpydsk_in

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL33@flpydsk_in

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN32@flpydsk_in
$LN54@flpydsk_in:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN32@flpydsk_in:

; 265  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
	npad	5
$LL41@flpydsk_in:

; 242  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	test	al, al
	js	SHORT $LN55@flpydsk_in

; 259  : }
; 260  : 
; 261  : //! get data from fdc
; 262  : uint8_t flpydsk_read_data () {
; 263  : 
; 264  : 	//! same as above function but returns data register for reading
; 265  : 	for (int i = 0; i < 500; i++ )

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL41@flpydsk_in

; 266  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	jmp	SHORT $LN40@flpydsk_in
$LN55@flpydsk_in:

; 267  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN40@flpydsk_in:

; 427  : 	for (int i=0; i<4; i++)

	sub	edi, 1
	jne	$LL6@flpydsk_in

; 276  : 	outportb (FLPYDSK_CTRL, val);

	push	edi
	push	1015					; 000003f7H
	call	?outportb@@YAXGE@Z			; outportb

; 434  : 	flpydsk_drive_data (3,16,240,true);

	push	1
	push	240					; 000000f0H
	push	16					; 00000010H
	push	3
	call	?flpydsk_drive_data@@YAXEEE_N@Z		; flpydsk_drive_data

; 435  : 
; 436  : 	//! calibrate the disk
; 437  : 	flpydsk_calibrate ( _CurrentDrive );

	movzx	eax, BYTE PTR ?_CurrentDrive@@3EA
	push	eax
	call	?flpydsk_calibrate@@YAHE@Z		; flpydsk_calibrate

; 518  : 
; 519  : 	//! reset the fdc
; 520  : 	flpydsk_reset ();
; 521  : 
; 522  : 	//! set drive information
; 523  : 	flpydsk_drive_data (13, 1, 0xf, true);

	push	1
	push	15					; 0000000fH
	push	1
	push	13					; 0000000dH
	call	?flpydsk_drive_data@@YAXEEE_N@Z		; flpydsk_drive_data
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi

; 524  : }

	ret	0
?flpydsk_install@@YAXH@Z ENDP				; flpydsk_install
_TEXT	ENDS
END
